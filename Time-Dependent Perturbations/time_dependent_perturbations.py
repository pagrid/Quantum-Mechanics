# -*- coding: utf-8 -*-
"""Time-Dependent Perturbations.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13dEpzU_J7fNW2YtpdZl58X-x7Cd8zTwT
"""

"""
Time-Dependent Perturbations for the Quantum Harmonic Oscillator
----------------------------------------------------------------
Author: Petros Agridos

This script computes matrix elements <ψ_m | x | ψ_n> for the quantum harmonic
oscillator, visualizes the squared matrix elements (coupling strengths),
evaluates time-dependent transition probabilities P(n -> m, t) under a
harmonic driving force, and scans resonance curves vs driving frequency.

Dependencies:
    numpy, matplotlib, scipy
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.special import eval_hermite
from scipy.integrate import quad
from math import factorial

# ----------------------------
# Physical constants & params
# ----------------------------
m = 1.0          # mass (in chosen units)
omega = 1.0      # natural frequency
hbar = 1.0       # reduced Planck constant (natural units)
alpha = m * omega / hbar   # scaling factor for HO basis
levels = 5       # number of energy levels to consider in the basis

# ----------------------------
# Wavefunction (Hermite-Gaussian)
# ----------------------------
def psi_n(n, x, alpha):
    """
    Normalized nth harmonic oscillator wavefunction (1D) in scaled units.

    ψ_n(x) = N * H_n( sqrt(alpha) x ) * exp(-alpha x^2 / 2)
    with N = (alpha/pi)^(1/4) * 1/sqrt(2^n n!)
    """
    # ensure x is scalar when used with quad (quad supplies floats)
    xi = np.sqrt(alpha) * x
    norm = (alpha / np.pi)**0.25 / np.sqrt(2**n * factorial(n))
    Hn = eval_hermite(n, xi)   # returns a scalar for scalar xi
    return norm * np.exp(-0.5 * alpha * x**2) * Hn

# ----------------------------
# Matrix element <psi_m | x | psi_n>
# ----------------------------
def matrix_element(n, m, alpha):
    """
    Calculate the matrix element <ψ_m | x | ψ_n> via numerical integration over (-inf, +inf).
    Uses scipy.integrate.quad for high-accuracy integration.
    """
    # integrand expects scalar x and returns scalar
    def integrand(x):
        return psi_n(m, x, alpha) * x * psi_n(n, x, alpha)

    result, err = quad(integrand, -np.inf, np.inf, epsabs=1e-9, epsrel=1e-9, limit=200)
    return result

# ----------------------------
# Build matrix of coupling elements
# ----------------------------
couplings = np.zeros((levels, levels))
for n in range(levels):
    for m in range(levels):
        couplings[n, m] = matrix_element(n, m, alpha)

# Visualize squared matrix elements (|<ψ_m|x|ψ_n>|^2)
plt.figure(figsize=(7, 6))
plt.imshow(couplings**2, origin='lower', cmap='viridis', extent=[0, levels-1, 0, levels-1])
plt.colorbar(label=r"$|\langle \psi_m | x | \psi_n \rangle|^2$")
plt.xlabel("Initial state n")
plt.ylabel("Final state m")
plt.title("Squared Coupling Matrix |<ψ_m | x | ψ_n>|^2")
plt.xticks(range(levels))
plt.yticks(range(levels))
plt.show()

# ----------------------------
# Transition probability (time-dependent perturbation, first-order-ish estimate)
# ----------------------------
def transition_probability(n, m, t, omega_d, F0):
    """
    Estimate transition probability P(n->m, t) induced by a driving force F0 cos(omega_d t).
    Uses the analytical-like formula:
      P ~ (|coupling|^2 / delta^2) * sin^2(delta t / (2 hbar))
    with delta = E_m - E_n - hbar*omega_d (detuning).
    Special-cased behavior for near-resonance (delta ~ 0): P ~ (coupling^2/hbar^2) * (t^2/4).
    Note: formula structure chosen to illustrate resonance; for exact Rabi-like dynamics
    a full time-dependent solver would be needed.
    """
    matrix_elem = matrix_element(n, m, alpha)
    coupling = F0 * matrix_elem
    E_n = (n + 0.5) * hbar * omega
    E_m = (m + 0.5) * hbar * omega
    # Energy difference between levels (without driving)
    energy_diff = E_m - E_n
    # Detuning relative to driving photon energy hbar*omega_d
    delta = energy_diff - hbar * omega_d

    # Avoid numerical division by zero: handle resonance case approximately
    if np.isclose(delta, 0.0, atol=1e-12):
        # On resonance the naive perturbative expression ~ (coupling^2 / hbar^2) * (t^2 / 4)
        return (coupling**2 / hbar**2) * (t**2) / 4.0
    else:
        arg = delta * t / (2.0 * hbar)
        return (coupling**2 / delta**2) * (np.sin(arg)**2)

# ----------------------------
# Time evolution for selected transitions
# ----------------------------
# time points
t = np.linspace(0, 200, 2000)   # choose longer window if desired

# driving params
F0 = 1e-3    # small driving amplitude (tune as needed)
omega_d = omega  # start at resonance with single-quantum transitions

transitions = [(0, 1), (1, 2), (2, 3), (3, 4)]
probabilities = {}
for (n, m) in transitions:
    probabilities[(n, m)] = np.array([transition_probability(n, m, tt, omega_d, F0) for tt in t])

# Plot time-dependent transition probabilities
plt.figure(figsize=(10, 6))
for (n, m), P in probabilities.items():
    plt.plot(t, P, label=f"$P_{{{n}\\to{m}}}(t)$")
plt.xlabel("Time (arb. units)")
plt.ylabel("Transition probability")
plt.title("Transition Probabilities vs Time (driving ω_d = ω)")
plt.legend()
plt.grid(alpha=0.3)
plt.ylim(bottom=0)
plt.show()

# ----------------------------
# Resonance scan: transition probability at fixed t_max vs driving frequency
# ----------------------------
def resonance_probability(n, m, omega_d, F0, t_max):
    """Compute transition probability P(n->m) at time t_max for a given omega_d."""
    return transition_probability(n, m, t_max, omega_d, F0)

t_max = 200.0
omega_d_range = np.linspace(0.5 * omega, 1.5 * omega, 500)

resonance_curves = {}
for (n, m) in transitions:
    resonance_curves[(n, m)] = np.array([resonance_probability(n, m, od, F0, t_max) for od in omega_d_range])

plt.figure(figsize=(10, 6))
for (n, m), curve in resonance_curves.items():
    plt.plot(omega_d_range / omega, curve, label=f"$P_{{{n}\\to{m}}}(t={t_max})$")
plt.xlabel(r"Driving frequency $\omega_d / \omega$")
plt.ylabel("Transition probability at t = t_max")
plt.title("Resonance Curves for Selected Transitions")
plt.legend()
plt.grid(alpha=0.3)
plt.show()